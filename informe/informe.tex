% Clase y configuracion de tipo de documento
\documentclass[10pt,a4paper,spanish]{article}
% Inclusion de paquetes
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[width=15.5cm, left=3cm, top=2.5cm, right=1cm, left=2cm, height= 24.5cm]{geometry}
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\usepackage{listings}
\usepackage{enumerate}
\usepackage{xspace}
\usepackage{longtable}
\usepackage{caratula}
\usepackage{mathtools}
\usepackage{caption}
\usepackage{color}

% incluye macros espec materia
%\include{algo1-cmds}

% Encabezado
\lhead{Algoritmos y Estructuras de Datos I}
\rhead{Grupo 1}
% Pie de pagina
\renewcommand{\footrulewidth}{0.4pt}
\lfoot{Facultad de Ciencias Exactas y Naturales}
\rfoot{Universidad de Buenos Aires}


\newcommand{\tab}{\-\hspace{0.5cm}}
\newcommand{\enter}{$\\[6pt]$}
\newcommand{\entermini}{$\\[2pt]$}
\newcommand{\requiere}[2] {\tab\textbf{requiere #1}: $#2$;\\[6pt]}
\newcommand{\asegura}[2] {\tab\textbf{asegura #1}: $#2$;\\[6pt]}
\newcommand{\modifica}[1] {\tab\textbf{modifica}: $#1$;\\[6pt]}
\newcommand{\aux}[1] {\textbf{aux #1}}

\begin{document}

% Datos de caratula
\materia{Algoritmos y Estructuras de Datos I}
\titulo{Trabajo Práctico Número 2}
%\subtitulo{}
\grupo{Grupo: 1}

\integrante{Ciruelos Rodríguez, Gonzalo}{063/14}{gonzalo.ciruelos@gmail.com}
\integrante{Gatti, Mathias}{477/14}{mathigatti@gmail.com}
\integrante{Rabinowicz, Lucía}{105/14}{lu.rabinowicz@gmail.com}
\integrante{Weber, Andres}{923/13}{herr.andyweber@gmail.com}

\maketitle

% Para crear un indice
%\tableofcontents

% Forzar salto de pagina
\clearpage

\section{Observaciones}

	\begin{enumerate}
		\item Dado que en el ejercicio de la demostracion nos era dificultoso implicar los aseguras del problema, los docentes nos sugirieron cambiar la especificacion de pop\_back por una mas fuerte, que es la que sigue:
\enter \textbf{problema pop\_back} $(a:[T])$ \{ \enter
\requiere{}{|a| > 0}
\modifica{a}
\asegura{sacaElUltimo}{pre(a) == a++[pre(a)[|pre(a)|-1]]}
\}

	\end{enumerate}

% Otro salto de pagina
% \newpage
\enter
\section{Especificación}

\subsection{posicionesMasOscuras}
\entermini \textbf{problema posicionesMasOscuras} ($im:Imagen$) = $result : [\langle\mathbb{Z},\mathbb{Z}\rangle]$ \{\enter
\asegura{}{mismos (result, [(i,j)| i \leftarrow [0..ancho(im)), j \leftarrow [0..alto (im)), \ esMinimo(sumaColor (color (im,i,j)), im)])}
\tab\aux{sumaColor}(p:Pixel):$\mathbb{Z}$ = red(p)+green(p)+blue(p);\\
\tab\aux{esMinimo}(s : $\mathbb{Z}$, im : Imagen) : Bool = $(\forall i \leftarrow [0..ancho(im)), \forall j \leftarrow [0..alto (im))) \ s \leq sumaColor(color (im,i,j));$
%\tab\aux{colorMinimo}(i:Imagen):$\mathbb{Z}$ = $min([sumaColor(color(i,x,y))|x\leftarrow [0..ancho(i)),i\leftarrow [0..alto(i))])$; \\
%\tab\aux{min} $(l:[\mathbb{Z}]):\mathbb{Z} =[l_i|(\forall i,j \leftarrow [0..|l|)) l_i \leq l_j]_0$;\\
\}

\subsection{top10}
\entermini \textbf{problema top10} ($g:Galeria$)=$result : [Imagen]$ \ {\enter
\asegura{}{0 \leq |result| \leq 10}
\asegura{}{|imagenes(g)| \leq 10 \implies mismos(result, imagenes(g))}
\asegura{}{|imagenes(g)| > 10 \implies |result| == 10}
\asegura{}{(\forall h \leftarrow result) h\in imagenes(g)}
\asegura{}{|imagenes(g)| >10 \implies [votos(g, i) | i \leftarrow result] == ordenarDecr([votos(g, i) | i \leftarrow imagenes(g)])[0..10)}
\asegura{}{ordenadaDecreciente([votos(g,result_i)|i\leftarrow[0..|result|)])}
\tab\aux{ordenadaDecreciente}$(l:[\mathbb{Z}]): Bool$ = $(\forall i,j \leftarrow [0..|l|), i\geq j)l_j \geq l_i;$\\
\tab\aux{ordenarDecr}$(l:[\mathbb{Z}]) : [\mathbb{Z}] $ = $[x\ |\ n \leftarrow [0..|l|], x \leftarrow l, cantidadMenores(l, x) == n];$ \\
\tab\aux{cantidadMenores}$(l:[\mathbb{Z}], x : \mathbb{Z}) : \mathbb{Z} $ = $|[y\ |\ y \leftarrow a, y < x]|$; \\
\}

\subsection{laMasChiquitaConPuntoBlanco}
\entermini \textbf{problema laMasChiquitaConPuntoBlanco} $(g:Galeria)$= $result:Imagen$ \{\enter
\requiere{existeImagenConPuntoBlanco}{(\exists h \leftarrow imagenes(g)) tieneBlanco (h)}
\asegura{}{tieneBlanco(result)}
\asegura{esLaMasChica}{(\forall j \leftarrow imagenesConBlanco(g)) ancho(result)*alto(result) \leq ancho(j)*alto(j) }
\tab\aux{imagenesConBlanco} $(g:Galeria):[Imagen]$=$[h|h \leftarrow imagenes (g), tieneBlanco (h)];$\\
\tab\aux{tieneBlanco}$(i:Imagen):Bool$=$(\exists x \leftarrow [0..ancho(i)),y \leftarrow [0..alto(i))) sumaColor (color(i,x,y))==255*3;$\\
\tab\aux{sumaColor}$(p:Pixel): \mathbb{Z}$ = $red(p)+green(p)+blue(p);$\\
\}

\subsection{agregarImagen}
\entermini \textbf{problema agregarImagen} $(g:Galeria,i:Imagen)$ \{ \enter
\requiere{}{i\notin imagenes(g)}
\modifica{g}
\asegura{agregaImagen}{mismos (imagenes(g),imagenes(pre(g))++[i])}
\asegura{}{votos(g,i)==0}
\asegura{noCambiaVotos}{(\forall h \leftarrow imagenes(pre(g))) votos(g,h) == votos(pre(g), h)}
\}

\subsection{votar}
\entermini \textbf{problema votar} $(g:Galeria,i:Imagen)$ \{ \enter
\requiere{}{i\in imagenes(g)}
\modifica{g}
\asegura{noCambiaImagenes}{mismos(imagenes(g),imagenes(pre(g)))}
\asegura{noCambiaVotosDelResto}{(\forall h \leftarrow imagenes(g), h\neq i) votos(g,h)==votos(pre(g),h)}
\asegura{}{votos(g,i)==votos(pre(g),i)+1}
\}

\subsection{eliminarMasVotada}
\entermini \textbf{problema eliminarMasVotada} $(g:Galeria)$ \{ \enter
\requiere{}{|imagenes(g)| > 0}
\modifica{g}
%\asegura{eliminaUnaImagen}{|imagenes (pre(g))| == |imagenes(g)|+1}
\asegura{eliminaUnaImagen}{|[h | h \leftarrow imagenes(pre(g)), h \notin imagenes(g)]| ==  1}
\asegura{eliminaUnaYNoPoneNadaMas\footnote{Notese que estos dos asegura implican que imagenes(g) es sublista de imagenes(pre(g)), dado que no tienen repetidos}}{|imagenes (pre(g))| ==   |imagenes(g)|+1}
\asegura{eliminaLaMasVotada}{(\forall h \leftarrow imagenes(pre(g))) \\
\indent \indent h \notin imagenes(g) \implies (\forall j \leftarrow imagenes(pre(g))) votos(pre(g), h) \geq votos(pre(g), j)}
\asegura{noCambiaVotos}{(\forall h \leftarrow imagenes(g))\  votos(pre(g), h) == votos(g, h)}
\}



\newpage
\section{Implementacion}
\renewcommand\lstlistingname{Código fuente}
\renewcommand\lstlistlistingname{Códigos fuente}


\definecolor{darkgreen}{RGB}{0,100,0}
\definecolor{darkblue}{RGB}{0,0,127}
\definecolor{orange}{RGB}{200,40,0}
\definecolor{grey}{RGB}{63,63,63}
\lstset{language=C++,
        basicstyle=\ttfamily\footnotesize,
        showstringspaces=false,
        numbers=left,
        numberstyle=\scriptsize,
        keywordstyle=\color{darkblue},
        commentstyle=\color{darkgreen},
        stringstyle=\color{orange},
        identifierstyle=\color{black},
        numberstyle=\tiny\color{grey}, 
}
Los headers (archivos .h) no fueron modificados con respecto a los originales, así que no los adjuntamos aquí.
\lstinputlisting[caption=pixel.cpp]{../src/pixel.cpp}
\lstinputlisting[caption=imagen.cpp]{../src/imagen.cpp}
\lstinputlisting[caption={galeria\_imagenes.cpp}]{\detokenize{../src/galeria_imagenes.cpp}}
\lstinputlisting[caption=main.cpp]{../src/main.cpp}

\newpage
\section{Demostraciones}
\small
\definecolor{cmntcolor}{RGB}{60,0,60}
\definecolor{notecolor}{RGB}{0, 128, 200}
\newcommand{\comment}[1]{\textcolor{cmntcolor}{\scriptsize{#1}}}

\subsection{Invariante de Representación y función de abstracción}
\enter
InvRep (imp: ClaseGaleriaImagen):\\
\indent$|imp.imagenes| ==  |imp.votos| \ \land$ \\
\indent$(\forall v \leftarrow imp.votos)\ v \geq 0 \ \land$ \\
\indent$(\forall i,j \leftarrow [0..|imp.imagenes|, i \neq j)\  imp.imagenes[i] \neq imp.imagenes[j]\ \land$ \\
\indent$(\forall i \leftarrow [0..|imp.votos|-1))\ imp.votos[i+1] \geq imp.votos[i]$ \\
\enter
\enter
abs (imp: ClaseGaleriaImagen, esp: Galeria):\\
\indent$mismos(imagenes(esp),imp.imagenes) \ \land$ \\
\indent$(\forall i \leftarrow [0..|imp.imagenes|)) votos(esp,imp.imagenes[i]) ==   imp.votos[i]$ \\
%\indent$(\forall h \leftarrow imagenes(esp), \forall i \leftarrow [0..|imp.imagenes|), imp.imagenes[i] == h)\ imp.votos[i]== votos(esp,h)$ \\

\subsection{Correctitud del Código}
\enter
\textbf{\textcolor{darkgreen}{void GaleriaImagenes :: eliminarMasVotada () \{}} \\

//estado 1; \\
\indent//vale $this == pre(this);$\\
\indent//vale $InvRep(pre(this));$ \comment{pues es metodo publico}\\
\indent//implica $abs(pre(this), pre(g));$ \\
\indent//vale $|this.imagenes|>0;$ \comment{pues valen los aseguras del problema}\\

\textbf{\textcolor{darkgreen}{imagenes . pop\_back ();}} \\

//estado 2; \\
\indent //vale $this@1.imagenes == this.imagenes ++ [this@1.imagenes[|this@1.imagenes|-1]];$ \comment{pues se cumplen los requieres de pop\_back, dado que $|this@1.imagenes|>0$}\\
\indent//vale $this.votos == this@1.votos;$ \\

\textbf{\textcolor{darkgreen}{votos . pop\_back ();}}\\

//estado 3; \\
\indent //vale $this@2.votos == this.votos ++ [this@2.votos[|this@2.votos|-1]];$ \comment{pues se cumplen los requieres de pop\_back, dado que $|this@1.votos ==  |this@1.imagenes|$ por $invRep(this@1)$ y a su vez $|this@1.imagenes|>0$}\\
\indent//vale $this.imagenes == this@2.imagenes;$ \\

\noindent
\textbf{\textcolor{darkgreen}{\}}}
\enter 

//Queremos ver que vale InvRep(this);\\
\indent  // (1); \\
\indent //vale $this.imagenes == this@2.imagenes \land \ this@2.votos == this.votos ++ [this@2.votos[|this@2.votos|-1]];$ \\
\indent //implica $pre(this).imagenes == this.imagenes ++ [pre(this).imagenes[|pre(this).imagenes|-1]]\  \land \ \\
\indent\indent pre(this).votos == this.votos ++ [pre(this).votos[|pre(this).votos|-1]];$   \comment{por las dos proposiciones anteriores y transformacion de estados} \\
\indent //implica $|pre(this).imagenes| == |this.imagenes| +1 \land \ |pre(this).votos| == |this.votos| +1;$ \comment{por propiedad de longitud} \\
\indent //implica $|imagenes| == |votos|$ \comment{pues $|pre(this).imagenes| == |pre(this).votos|$ por $InvRep(pre(this))$} \\

\indent // (2); \\
\indent //vale $this@2.votos == this.votos ++ [this@2.votos[|this@2.votos|-1]];$ \\
\indent //implica $pre(this).votos == this.votos ++ [pre(this).votos[|pre(this).votos|-1]];$  \comment{por transformacion de estados}\\
\indent //implica $ (\forall v \leftarrow this.votos) v \geq 0;$ \comment{pues es una sublista de $pre(this).votos$ y vale para esta lista por $InvRep(pre(this))$} \\

\indent // (3); \\
\indent //vale $this@1.imagenes == this.imagenes ++ [this@1.imagenes[|this@1.imagenes|-1]];$ \\
\indent //implica $pre(this).imagenes == this.imagenes ++ [pre(this).imagenes[|pre(this).imagenes|-1]];$ \comment{por transformacion de estados}\\
\indent //implica $(\forall i,j \leftarrow [0..|this.imagenes]) i \neq j) this.imagenes[i] \neq this.imagenes[j];$ \comment{pues es una sublista de $pre(this).imagenes$ y vale para esta lista por $InvRep(pre(this))$}\\

\indent // (4); \\
\indent //vale $this@2.votos == this.votos ++ [this@2.votos[|this@2.votos|-1]];$ \\
\indent //implica $pre(this).votos == this.votos ++ [pre(this).votos[|pre(this).votos|-1]];$ \comment{por transformacion de estados}\\
\indent // implica $(\forall i \leftarrow [0..|this.votos|-1)) this.votos[i+1] \geq this.votos[i];$ \comment{pues this.votos es sublista de $pre(this).votos$, que esta ordenada por $InvRep(pre(this))$}
\enter
\indent //vale $InvRep(this);$ \\
\indent //implica $abs(this, g);$ \\\enter
\indent //Ahora queremos ver que valen los aseguras del problema\footnote{De aquí en adelante,  $sinrepetidos$($xs : [T]$) : Bool = $(\forall i,j \leftarrow [0..|xs|), i \neq j)\  xs[i] \neq xs[j]$}\\
\indent //(1);\\
\indent //vale $this.imagenes == this@2.imagenes$; \comment{por transformacion de estados}\\
\indent //implica $pre(this).imagenes == this.imagenes ++ [pre(this).imagenes[|pre(this).imagenes|-1]];$ \comment{por pop\_back, justificado en la transformacion de estados}\\
\indent //implica $|[h | h \leftarrow pre(this).imagenes, h \notin this.imagenes]| == 1$; \comment{pues ese elemento que no está es el ultimo, como se ve claramente en la proposicion anterior, y porque las listas no tienen repetidos, dado que vale invRep(this) e invRep(pre(this))}\\
\indent //vale $mismos(pre(this).imagenes, imagenes(pre(g)))$; \comment{por abs(pre(this), pre(g))}\\
\indent //vale $mismos(this.imagenes, imagenes(g))$; \comment{por abs(this, g)} \\
\indent // implica $|[h | h \leftarrow imagenes(pre(g)), h \notin imagenes(g)]| ==  1$; \comment{pues usamos los dos ultimos vales ya que iterar sobre listas que son mismos es lo mismo}\\

\indent //(2);\\
\indent //vale $mismos(this.imagenes, imagenes(g));$ \comment{por abs(this, g)} \\
\indent //vale $mismos(pre(this).imagenes, imagenes(g));$ \comment{por abs(pre(this), pre(g))} \\
\indent //implica $|imagenes(g)| == |this.imagenes| \land \ |imagenes(pre(g))| == |pre(this).imagenes|;$ \\
\indent //vale $|pre(this).imagenes| == |this.imagenes|+1;$ \comment{por transformacion de estados y propiedades de longitud, justificado antes}\\
\indent //implica $|imagenes(g)|+1 == |imagenes(pre(g))|;$ \comment{por las dos proposiciones anteriores}\\


\indent // (3);\\
\indent //vale $pre(this).votos ==  this.votos ++ pre(this).votos[|pre(this).votos|-1]; $ \comment{por poscondicion de pop\_back dado que se cumplen los requieres por los requieres de eliminarMasVotada ya que $|pre(this).votos| == |pre(this).imagenes| > 0$ }\\
\indent //vale $pre(this).imagenes ==  this.imagenes ++ pre(this).imagenes[|pre(this).imagenes|-1];$ \comment{por poscondicion de pop\_back, por la justificacion de antes}\\
\indent //vale $sinrepetidos(this.imagenes) \land sinrepetidos(pre(this).imagenes);$ \comment{por invRep(pre(this))}\\
\indent //vale $(\forall i \leftarrow [0..|pre(this).votos|-1)) pre(this).votos[i+1] \geq pre(this)votos[i] ;$ \comment{por invRep(pre(this))}\\
\indent //vale $(\forall i \leftarrow [0..|this.votos|-1)) this.votos[i+1] \geq this.votos[i] ;$ \comment{por invRep(this)} \\
\indent //implica $(\forall i \leftarrow [0..|this.votos|-1)) this.votos[|pre(this).votos-1|] \geq this.votos[i];$ \comment{ya que this.votos esta contenido en pre(this).votos y por invRep(pre(this)) e invRep(this) ambas estan ordenadas en forma creciente}\\
\indent //implica $ pre(this).imagenes[|pre(this).imagenes-1|] \notin this.imagenes \land\\
  \indent\indent(\forall h \leftarrow pre(this).imagenes, h \neq pre(this).imagenes[|pre(this).imagenes-1|] ) h \in this.imagenes $ \comment{primera mitad de la conjuncion por sinrepetidos y el segundo vale y la segunda mitad por el segundo vale}\\
\indent //vale $(\forall i \leftarrow [0..|pre(this).imagenes|))votos(pre(g),pre(this).imagenes[i]) ==  pre(this).votos[i] \land\\
  \indent\indent(\forall i \leftarrow [0..|this.imagenes|))votos(g,this.imagenes[i]) ==  this.votos[i]; $ \comment{por abs(pre(this), pre(g)) ya que se cumple al principio y abs(this, g) ya que se demostro previamente que valia el invariante de representacion al final}\\
\indent //vale $ mismos(pre(this).imagenes,imagenes(pre(g))) \land mismos(this.imagenes,imagenes(g));$ \comment{por abs(pre(this), pre(g)) ya que se cumple el invariante al inicio de la ejecucion}\\
\indent //implica $mismos(imagenes(pre(g)),imagenes(g) ++ imagenes(pre(g))[imagenes(pre(g))-1]) \land\\
  \indent\indent mismos(votos(pre(g)),votos(g) ++ votos(pre(g))[votos(pre(g))-1]);$ \comment{por abs(pre(this), pre(g)) , abs(this, g) y los primeros dos vale}\\
\indent //implica $(\forall h \leftarrow imagenes(pre(g))) h \notin imagenes(g) \implies (\forall j \leftarrow imagenes(pre(g))) votos(pre(g),h) \geq votos(pre(g),j);$ \comment{si no pertenece a imagenes(g) entonces es el que tiene mas votos, se deduce de los primeros dos implica y de abs(pre(this), pre(g)) y abs(this, g), ya que las imagenes de g y this (y pre(g) y pre(this)) son mismos y comparten los votos}
\enter

\indent //(4);\\
\indent //vale $this@2.votos == this.votos ++ [this@2.votos[|this@2.votos|-1]];$ \comment{(estado 3)}\\
\indent //vale $this@1.votos == this.votos ++ [this@1.votos[|this@1.votos|-1]];$ \comment{pues $this@2.votos == this@1.votos$, dado que la primera instruccion no lo modifica}\\
\indent //vale $pre(this).votos ==  this.votos ++ pre(this).votos[|votos.pre(this)|-1]; $ \comment{pues $this@1 == pre(this)$}\\
\indent //vale $this.imagenes == this@2.imagenes;$\\
\indent //vale $this@1.imagenes ==  this.imagenes ++ this@1.imagenes[|this@1.imagenes|-1]; $ \comment{por poscondicion de pop\_back, dado que se cumplen los requieres por los requieres de eliminarMasVotada ya que $|pre(this).votos| == |pre(this).imagenes| > 0 (ver estado 2)$}\\
\indent //vale $pre(this).imagenes ==  this.imagenes ++ pre(this).imagenes[|pre(this).imagenes|-1]; $ \comment{pues $this@1 == pre(this)$}\\
\indent //\textcolor{notecolor}{por lo tanto, tenemos ${(*)}$}  $pre(this).imagenes ==  this.imagenes ++ pre(this).imagenes[|pre(this).imagenes|-1] \land pre(this).votos ==  this.votos ++ pre(this).votos[|pre(this).votos|-1];$ \\
\indent //vale $sinrepetidos(this.imagenes);$ \comment{por invRep(this)}\\
\indent //vale $sinrepetidos(this.imagenes) \land sinrepetidos(pre(this).imagenes);$ \comment{por invRep(pre(this)) y predicado anterior}\\
\indent //implica $ pre(this).imagenes[|pre(this)|-1] \notin this.imagenes;$ \comment{por ${(*)}$} \\
\indent //implica $(\forall h \leftarrow this.imagenes) h \in pre(this).imagenes;$ \comment{pues por ${(*)}$, $this.imagenes$ es sublista}\\
\indent //implica $(\forall j \leftarrow [0..|this.imagenes|)) this.imagenes[j] ==  pre(this).imagenes[j] \land\\
\indent\indent\indent\ \ \  (\forall j \leftarrow [0..|this.votos|)) this.votos[j] ==  pre(this).votos[j]$ \comment{por ${(*)}$ dado que estoy diciendo que las listas son las mismas hasta el largo de la mas corta (${(*)}$ dice exactamente eso, es decir, las listas son iguales excepto por el ultimo elemento, que a una le falta)}\\
\indent //implica $(\forall i \leftarrow [0..|this.imagenes|)) pre(this).votos[i] ==  this.votos[i];$ \comment{por la proposicion anterior, los vectores de imagenes y votos de this y pre(this) estan ordenados igual y sin repetidos, entonces para todas las imagenes de this.imagenes compartiran los votos}\\
\indent //vale $ mismos(pre(this).imagenes,imagenes(pre(g))) \land mismos(this.imagenes,imagenes(g));$ \comment{por abs(pre(this), pre(g)) y abs(this, g)}\\
\indent //implica $mismos(imagenes(pre(g)),imagenes(g) ++ imagenes(pre(g))[|imagenes(pre(g))|-1]);$ \comment{por ${(*)}$, es un simple reemplazo sintactico}\\
\indent //vale $(\forall i \leftarrow [0..|pre(this).imagenes|))votos(pre(g),pre(this).imagenes[i]) ==  pre(this).votos[i] \land\\
\indent\indent(\forall i \leftarrow [0..|this.imagenes|))votos(g,this.imagenes[i]) ==  this.votos[i]; $ \comment{por abs(pre(this), pre(g)) y abs(this, g)} \\
\indent // implica $(\forall h \leftarrow imagenes(g)) votos(pre(g),h) ==  votos(g,h);$ \comment{por ${(*)}$ todas las imagenes de this van a estar en pre(this), gracias a la anteultima proposicion (mismos\dots) puedo reemplazar $this.imagenes$ por $imagenes(g)$ y por la ultima proposicion sus votos seran iguales para cada imagen de g}\\
\end{document}

